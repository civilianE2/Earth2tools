<!DOCTYPE html>
<html>
<head>
    <title>E2V1 Daylight Map by Civilian â€” Earth2.fi</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        #map { height: 100vh; width: 100%; background: #00050a; cursor: crosshair; }
        body { margin: 0; background: #111; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        .info { position: absolute; top: 10px; left: 50px; z-index: 1000; background: rgba(0,0,0,0.85); padding: 15px; border-radius: 8px; border: 1px solid #00d4ff; pointer-events: none; }
        .leaflet-popup-content-wrapper { background: transparent; box-shadow: none; padding: 0; }
        .leaflet-popup-tip { background: #1a1a1a; }
    </style>
</head>
<body>
    <div class="info">
        <b style="color: #00d4ff;">E2V1 Daylight Map by Civilian</b><br>
        â€¢ Earth2.fi<br>
        â€¢ Click to view E2V1 time and the sun
    </div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        const corner1 = L.latLng(-85, -180);
        const corner2 = L.latLng(85, 180);
        const bounds = L.latLngBounds(corner1, corner2);

        const map = L.map('map', {
            maxBounds: bounds,
            maxBoundsViscosity: 1.0,
            minZoom: 2,
            worldCopyJump: false
        }).setView([60, 24], 4);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            noWrap: true,
            bounds: bounds
        }).addTo(map);

        const shadowGroup = L.layerGroup().addTo(map);

        function getSolarDeclination() {
            const now = new Date();
            const start = new Date(now.getFullYear(), 0, 0);
            const dayOfYear = Math.floor((now - start) / 86400000);
            return (23.45 * Math.sin((2 * Math.PI / 365) * (dayOfYear - 81))) * Math.PI / 180;
        }

        function calculateSunTimes(lat, lon) {
            const latRad = lat * Math.PI / 180;
            const decl = getSolarDeclination();
            const cosH = (Math.sin(-0.833 * Math.PI / 180) - Math.sin(latRad) * Math.sin(decl)) / (Math.cos(latRad) * Math.cos(decl));
            if (cosH > 1) return { rise: "Polar Night", set: "Polar Night" };
            if (cosH < -1) return { rise: "Midnight Sun", set: "Midnight Sun" };
            const H = Math.acos(cosH) * (180 / Math.PI) / 15;
            const solarNoon = 12 - (lon / 15);
            const format = (h) => {
                const totalM = (h * 60 + 1440) % 1440;
                return `${Math.floor(totalM/60).toString().padStart(2,'0')}:${Math.floor(totalM%60).toString().padStart(2,'0')}`;
            };
            return { rise: format(solarNoon - H), set: format(solarNoon + H) };
        }

        function updateShadows() {
            shadowGroup.clearLayers();
            const decl = getSolarDeclination();
            const now = new Date();
            
            const drawLayer = (limit, color, opacity) => {
                for (let lon = -180; lon < 180; lon += 1.5) {
                    let points = [];
                    for (let lat = 85; lat >= -85; lat -= 3) {
                        const latRad = lat * Math.PI / 180;
                        const utcSecs = (now.getUTCHours() * 3600) + (now.getUTCMinutes() * 60) + now.getUTCSeconds();
                        // IMPORTANT FIX: Added Math.PI
                        const hourAngle = (((((utcSecs + (lon/15)*3600)*4)%86400)/86400)*360-180)*Math.PI/180;
                        const alt = Math.asin(Math.sin(latRad)*Math.sin(decl) + Math.cos(latRad)*Math.cos(decl)*Math.cos(hourAngle)) * (180/Math.PI);
                        if (alt < limit) points.push([lat, lon]);
                    }
                    if (points.length > 0) {
                        L.polygon(points.concat(points.map(p => [p[0], p[1] + 1.5]).reverse()), {
                            fillColor: color, fillOpacity: opacity, stroke: false, interactive: false
                        }).addTo(shadowGroup);
                    }
                }
            }
            drawLayer(0, '#000', 0.25);
            drawLayer(-12, '#000', 0.45);
        }

  map.on('click', function(e) {
            const { lat, lng } = e.latlng;
            const sunUTC = calculateSunTimes(lat, lng);
            
            const updatePopup = () => {
                const now = new Date();
                const zoneOffset = Math.floor((lng + 7.5) / 15); 
                const utcSecs = (now.getUTCHours() * 3600) + (now.getUTCMinutes() * 60) + now.getUTCSeconds();
                
                // Funktio, joka muuttaa normaalin UTC-ajan (HH:MM) E2V1-ajaksi
                const convertToE2V1 = (utcStr) => {
                    if (utcStr.includes("Polar") || utcStr.includes("Sun")) return utcStr;
                    const [h, m] = utcStr.split(':').map(Number);
                    const totalSecs = (h * 3600) + (m * 60);
                    
                    // Lasketaan E2V1: (Aika + VyÃ¶hyke) * 4
                    // KÃ¤ytetÃ¤Ã¤n % 86400 jotta kello pysyy 24h raameissa
                    const e2Total = ((totalSecs + (zoneOffset * 3600)) * 4) % 86400;
                    
                    const resH = Math.floor(e2Total / 3600).toString().padStart(2,'0');
                    const resM = Math.floor((e2Total % 3600) / 60).toString().padStart(2,'0');
                    return `${resH}:${resM}`;
                };

                const e2v1Rise = convertToE2V1(sunUTC.rise);
                const e2v1Set = convertToE2V1(sunUTC.set);

                // Nykyinen E2V1 Kellonaika
                const e2v1Total = ((utcSecs + (zoneOffset * 3600)) * 4) % 86400;
                const h = Math.floor(e2v1Total / 3600).toString().padStart(2,'0');
                const m = Math.floor((e2v1Total % 3600) / 60).toString().padStart(2,'0');
                const s = Math.floor(e2v1Total % 60).toString().padStart(2,'0');

                popup.setContent(`
                    <div style="background: #1a1a1a; color: white; padding: 15px; font-family: sans-serif; border-radius: 8px; border: 1px solid #333; min-width: 220px;">
                        <h2 style="margin: 0 0 5px 0; color: #00d4ff; font-size: 14px; text-transform: uppercase;">VyÃ¶hyke UTC${zoneOffset >= 0 ? '+' : ''}${zoneOffset}</h2>
                        <div style="background: #252525; padding: 12px; border-radius: 6px; border-left: 4px solid #ffcc00; margin: 10px 0;">
                            <span style="font-size: 10px; color: #aaa; text-transform: uppercase;">E2V1 Kellonaika:</span><br>
                            <span style="font-size: 32px; font-weight: bold; color: #ffcc00;">${h}:${m}:${s}</span>
                        </div>
                        <div style="font-size: 13px; line-height: 1.6;">
                            ðŸŒ… <b>E2V1 Nousu:</b> ${e2v1Rise}<br>
                            ðŸŒ‡ <b>E2V1 Lasku:</b> ${e2v1Set}
                        </div>
                        <div style="border-top: 1px solid #333; margin-top: 10px; padding-top: 5px; font-size: 10px; color: #555; text-align: right;">
                            E2V1 Localized Time
                        </div>
                    </div>
                `);
            };

            const popup = L.popup({ minWidth: 250 })
                .setLatLng(e.latlng)
                .openOn(map);
            
            const timer = setInterval(updatePopup, 250);
            map.on('popupclose', () => clearInterval(timer));
            updatePopup();
        });
        setInterval(updateShadows, 10000);
        updateShadows();
    </script>
</body>
</html>
