<!DOCTYPE html>
<html>
<head>
    <title>E2V1 Daytime & Moon Visualizer by Civilian</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        #map { height: 100vh; width: 100%; background: #aad3df; cursor: crosshair; }
        body { margin: 0; background: #111; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        .info { position: absolute; top: 10px; left: 50px; z-index: 1000; background: rgba(0,0,0,0.85); padding: 15px; border-radius: 8px; border: 1px solid #00d4ff; pointer-events: none; }
        .leaflet-popup-content-wrapper { background: transparent; box-shadow: none; padding: 0; }
        .leaflet-popup-tip { background: #1a1a1a; }
    </style>
</head>
<body>
    <div class="info">
        <b style="color: #00d4ff;">E2V1 Daylight & Moon Map</b><br>
        â€¢ Earth2.fi â€¢ Click to see local E2V1 stats
    </div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        const map = L.map('map', {
            maxBounds: L.latLngBounds(L.latLng(-85, -180), L.latLng(85, 180)),
            maxBoundsViscosity: 1.0,
            minZoom: 2,
            worldCopyJump: false
        }).setView([60, 24], 4);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
            noWrap: true,
            attribution: 'Â©OpenStreetMap, Â©CartoDB'
        }).addTo(map);

        const shadowGroup = L.layerGroup().addTo(map);

        function getSolarDeclination() {
            const now = new Date();
            const start = new Date(now.getFullYear(), 0, 0);
            const dayOfYear = Math.floor((now - start) / 86400000);
            return (23.45 * Math.sin((2 * Math.PI / 365) * (dayOfYear - 81))) * Math.PI / 180;
        }

        function calculateSunTimes(lat, lon) {
            const latRad = lat * Math.PI / 180;
            const decl = getSolarDeclination();
            const cosH = (Math.sin(-0.833 * Math.PI / 180) - Math.sin(latRad) * Math.sin(decl)) / (Math.cos(latRad) * Math.cos(decl));
            if (cosH > 1) return { rise: "Polar Night", set: "Polar Night" };
            if (cosH < -1) return { rise: "Midnight Sun", set: "Midnight Sun" };
            const H = Math.acos(cosH) * (180 / Math.PI) / 15;
            const solarNoonUTC = 12 - (lon / 15);
            const zoneOffset = Math.floor((lon + 7.5) / 15);
            const format = (hUTC) => {
                const local = (hUTC + zoneOffset + 24) % 24;
                return `${Math.floor(local).toString().padStart(2,'0')}:${Math.floor((local%1)*60).toString().padStart(2,'0')}`;
            };
            return { rise: format(solarNoonUTC - H), set: format(solarNoonUTC + H) };
        }

        function calculateMoonData(lat, lon, date) {
            const zoneOffset = Math.floor((lon + 7.5) / 15);
            const dayIdx = (date - new Date(2000, 0, 1)) / 86400000;
            const lp = 255.1 + 29.10132486 * dayIdx;
            const phase = (lp % 30) / 30;
            let moonRiseH = (12 + (phase * 24) + (lon / 15) + 24) % 24;
            const format = (h) => {
                const local = (h + zoneOffset + 24) % 24;
                return `${Math.floor(local).toString().padStart(2,'0')}:${Math.floor((local%1)*60).toString().padStart(2,'0')}`;
            };
            const phases = ["New Moon ðŸŒ‘", "Waxing Crescent ðŸŒ’", "First Quarter ðŸŒ“", "Waxing Gibbous ðŸŒ”", "Full Moon ðŸŒ•", "Waning Gibbous ðŸŒ–", "Last Quarter ðŸŒ—", "Waning Crescent ðŸŒ˜"];
            return { rise: format(moonRiseH), set: format((moonRiseH + 12) % 24), phase: phases[Math.floor(phase * 8)] };
        }

        function updateShadows() {
            shadowGroup.clearLayers();
            const decl = getSolarDeclination();
            const now = new Date();
            const drawLayer = (limit, color, opacity) => {
                for (let lon = -180; lon < 180; lon += 2.5) {
                    let points = [];
                    for (let lat = 85; lat >= -85; lat -= 5) {
                        const latRad = lat * Math.PI / 180;
                        const utcSecs = (now.getUTCHours() * 3600) + (now.getUTCMinutes() * 60) + now.getUTCSeconds();
                        const hourAngle = (((((utcSecs + (lon/15)*3600)*4)%86400)/86400)*360-180)*Math.PI/180;
                        const alt = Math.asin(Math.sin(latRad)*Math.sin(decl) + Math.cos(latRad)*Math.cos(decl)*Math.cos(hourAngle)) * (180/Math.PI);
                        if (alt < limit) points.push([lat, lon]);
                    }
                    if (points.length > 0) {
                        L.polygon(points.concat(points.map(p => [p[0], p[1] + 2.5]).reverse()), { fillColor: color, fillOpacity: opacity, stroke: false, interactive: false }).addTo(shadowGroup);
                    }
                }
            }
            drawLayer(0, '#000', 0.35);
            drawLayer(-12, '#000', 0.50);
        }

        map.on('click', function(e) {
            const { lat, lng } = e.latlng;
            const sun = calculateSunTimes(lat, lng);
            const zoneOffset = Math.floor((lng + 7.5) / 15);
            
            // KORJAUS: LisÃ¤tty autoPan: false ja offset, jotta popup ei heiluta ruutua
            const popup = L.popup({ 
                minWidth: 250, 
                autoPan: false, 
                offset: [0, -10] 
            })
            .setLatLng(e.latlng)
            .openOn(map);

            const updatePopup = () => {
                const now = new Date();
                const moon = calculateMoonData(lat, lng, now);
                const e2v1Total = (((now.getUTCHours()*3600 + now.getUTCMinutes()*60 + now.getUTCSeconds()) + (zoneOffset*3600)) * 4) % 86400;
                const h = Math.floor(e2v1Total/3600).toString().padStart(2,'0');
                const m = Math.floor((e2v1Total%3600)/60).toString().padStart(2,'0');
                const s = Math.floor(e2v1Total%60).toString().padStart(2,'0');
                
                popup.setContent(`
                    <div style="background: #1a1a1a; color: white; padding: 15px; font-family: sans-serif; border-radius: 8px; border: 1px solid #333; min-width: 220px;">
                        <h2 style="margin: 0 0 5px 0; color: #00d4ff; font-size: 14px; text-transform: uppercase;">Zone UTC${zoneOffset >= 0 ? '+' : ''}${zoneOffset}</h2>
                        <div style="background: #252525; padding: 12px; border-radius: 6px; border-left: 4px solid #ffcc00; margin: 10px 0;">
                            <span style="font-size: 10px; color: #aaa; text-transform: uppercase;">E2V1 Local Time:</span><br>
                            <span style="font-size: 32px; font-weight: bold; color: #ffcc00;">${h}:${m}:${s}</span>
                        </div>
                        <div style="font-size: 13px; line-height: 1.6; border-bottom: 1px solid #333; padding-bottom: 8px; margin-bottom: 8px;">
                            ðŸŒ… <b>Sunrise:</b> ${sun.rise}<br>
                            ðŸŒ‡ <b>Sunset:</b> ${sun.set}
                        </div>
                        <div style="font-size: 13px; line-height: 1.6;">
                            ðŸŒ™ <b>Moonrise:</b> ${moon.rise}<br>
                            ðŸŒ‘ <b>Moonset:</b> ${moon.set}<br>
                            âœ¨ <b>Phase:</b> ${moon.phase}
                        </div>
                    </div>
                `);
            };

            const timer = setInterval(updatePopup, 250);
            map.on('popupclose', () => clearInterval(timer));
            updatePopup();
        });

        setInterval(updateShadows, 10000);
        updateShadows();
    </script>
</body>
</html>
